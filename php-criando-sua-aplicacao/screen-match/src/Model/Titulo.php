<?php
// palavra reservada namespace serve para mostrar que essa minha classe faz parte de um "pacote/pasta virtual/grupo de outras classes" chamada "Model" por exemplo (como estou fazendo abaixo)
// namespace do que eu definir neste arquivo é: "ScreenMatch\Model"
// contra barra "\" é como separamos/organiza diversos namespace, aqui, tenho um namespace "ScreenMatch\Modelo", por padrão teremos um namespace global, no caso "ScreenMatch\" e dentro de cada pasta que organizamos nosso projeto, teremos um namespace, como no caso abaixo: "Model" - pode-se colcoar qualquer nome, mas como boa prática, colocamos o nome das "pastas atuais" mesmo, mapeando da mesma forma que temos nossa estrutura de pastas
// nesse primeiro momento estou sendo retornado com vários erros neste arquivo pois ao definir um namespace, tudo que irei buscar será procurado nele (coisa que não estou achando no momento, como a interface Avaliavel e a trait ComAvaliacao, que no momento não se encontram no namespace definido "ScreenMatch/Model", mesma coisa para o Enum "Genero", ele busca esses arquivos externos no namespace, apenas nele (caso claro, em uma situação como essa que não estamos trazendo nenhum outro namespace)) - classes também podem ser chamadas de "símbolos"
// não é obrigatório que os namespaces estejam em outras pastas (como por exemplo, eu poderia ter um namespace na pasta raiz(junto do index) que representasse algo no meu sistema (model) e colcoar um namespace lá e chama-lo no index, posso sim fazer isso, mas como boa prática, nossos namespaces ficam em pastas separadas, permitindo que fiquem mais organizados e legíveis)
namespace ScreenMatch\Model;

/**
 * concreta = contrário de abstrata (pois concreta é algo já definido, abstrato algo que ainda está "em ideia")
 * Titulo é uma classe abstrata pois é genérica, é apenas uma base para outras classes (classes que irão se especializar a partir dessa aqui, se tornando em séries, filmes, mini séries, documentários...mas nunca deixando de ser um "titulo", pois as subclasses herdarão de título)
 * classes abstratas podem ter métodos abstratos (métodos que serão implementados (ou seja, terá uma definição de comportamento) pelas classes filhas obrigatoriamente. obs: para não ter que implementar o método abstrato da classe pai obrigatoriamente, a classe que herdou da classe abstrata teria de ser abstrata também , e por exemplo, série extendeu de Titulo, porém serie também é abstrata, logo, ela não é obrigada a implementar um método definido como abstrato na classe pai, porém a classe que herdar de série e não for abstrata tera de o fazer(definir uma implementação para o método abstrato da classe pai de Serie))
 * não podem ser instanciadas (ou seja, não é possivel fazer objetos a partir da classe titulo, apenad das classes filhas que NÃO são abstratas), ele ainda é um tipo, posso receber PARÂMETROS do tipo Titulo, posso retornar valores do tipo Titulo, porém a instância do objeto/variavel em si, o valor real (como por exemplo tentar acessar diretamnente os valores dos atributos de um titulo) é impossível, apenas se feito atráves da instancia de um objeto de uma classe filha/classe concreta (algo que herdou de titulo), tanto que, se repararmos, no nosso arquivo de calculadora recebemos uma "instância de titulo", porém, sempre será passado uma série ou filme (deixando nos parametros daquela forma: Titulo $titulo permite que passemos tanto um filme, serie, documentario... tudo para o mesmo método e ainda filtrando com uma tipagem correta (Titulo), bloqueando entradas do tipo "string, int, float..." e recebendo apenas o que precisamos, pois, no fundo, toda série, filme e documentário são um título por debaixo dos panos, imagina ter que fazer um método para cada tipo? um para série, outro documentário, outro filme.... ia ser uma bagunça, não? assim conseguimos "matar vários coelhos com uma cajadada só", permitindo apenas coisas que são titulo/herdem de título (séries, filmes, documentarios..))
 * "certo, porém e se eu tivesse mais alguma coisa nesse meu contexto que herdasse de titulo e não fizesse sentido ter esse método de "duração em minutos"?", nesse caso podemos fazer uma implementação falsa (apenas dando um return 0 para corresponder a sintaxe que EXIGE um retorno do tipo inteiro) ou usar a linha de raciocinio mais sensata, que é: "nesse nosso contexto/regra de negócio o que iria existir/qual classe iriamos criar herdando de titulo que NÃO FARIA SENTIDO ter o método duracaoEmMinutos?" exatamente, até onde consigo pensar, não tem nada e se tiver, realmente faz sentido? (se sim, vem a aplicação de esta classe que não precisa do metodo duracaoEmMinutos ser abstrata ou simplemente ter uma falsa implementação) porém, até onde consigo pensar, simplemente não faz sentido nenhuma nao ter, pois toda miniserie, documentario, video, propaganda (coisas que fariam sentido nessa aplicação/nossa regra de negócio) possuem uma duração em minutos, eles precisam desse método (cada um com seu jeito de implementar como vai funcionar a partir daquela classe que herdou de titulo), então, sim, com basse na nossa regra de negócio, tudo que herdar de titulo realmente faz sentido possuir esse método (obs: inclusive no exemplo do proximo video que irei ver, onde é mostrado que, teremos uma classe relacionada com episodios, e sim, todo episodio possui uma duração em minutos, logo, faz sentido TODO episiodio (todo objeto instanciado a partir da classe que iremos criar cuidando das funcionalidades e atributos dos "episodios") possuir esse método de duracaoEmMinutos())
 * agora, estamos implementando uma interface chamada Avaliavel, que possui apenas métodos abstratos, como essa classe é abstrata, não precisa implementar os seus métodos, mas TODAS as classes filhas de titulo para serem consideradas um título, PRECISAM implementar todos os métodos que a interface "Avaliavel" diz ter - "todo mundo que herdar de Titulo, também é Avaliavel"
 */
abstract class Titulo implements Avaliavel
{
    // dizendo que nossa classe Titulo vai utilizar nossa Trait(característica) ComAvaliacao - logo, as subclasses(classes filhas/que herdam de Titulo também terão acesso)
    // por debaixo dos panos o que essa palavra reservada use faz é o mesmo que o require nos arquivos principais, ele pega, copia o conteúdo dentro das chaves {} da nossa Trait e cola aqui, apenas isso, logo, dessa forma, teremos acesso ao atributo privado $notas e os métodos "media()" e "avalia(float $nota)"
    // como removemos os métodos desse arquivo, ele apitaria um erro dizendo que ele precisa ter os métodos "media()" e "avalia(float $nota)" devido ao nosso contrato (interface) que diz que DEVEMOS ter esses métodos para podermos existir, porém, eles são implementados na nossa Trait, e como expliquei acima, ao usar o "use" estamos copiando e colando o conteúdo da nossa trait, onde estamos implementando justamente os métodos "media()" e "avalia(float $nota)" que precisamos para cumprir com "as condições do nosso contrato"
    // é possivel utilizar mais de uma trait (obviamente, com métodos com nomes diferentes), separando por "," em um único "use" ou colocando vários "use" um abaixo do outro
    // obs importante: palavra reservada "use" importa uma trait quando ela está dentro de uma classe, fora de uma classe a palavra reservada "use" importa um nome para um arquivo dizendo que quero usar aquele "nome" no escopo do meu arquivo (basicamente encurtar o caminho para que eu use apenas o último nome daquele caminho no meu arquivo, por exemplo no meu index.php: use ScreenMatch\Model\Avaliavel - estou dizendo que quero usar a interface Avaliavel no meu arquivo, e para me referenciar a ela, usarei apenas "Avaliavel" - que é, o último nome do caminho use ScreenMatch\Model\Avaliavel)
    use ComAvaliacao;
    // classe "Titulo" que vai possuir as características em comum tanto da classe "Filme" quanto da classe "Serie", pois, eles tem muita coisa em comum e sem esse método que usaremos aqui, teriamos que repetir muito código, o que, pensando em boas práticas e no futuro, não é uma ação recomendada (pois, caso fique duplicando código, caso nossa regra de negócio mude ou aquela (por exemplo) método de problema ou precise de reestrutruração? teria que mudar tudo manualmente, o que pode causar um caos e mais problemas, dessa forma que faremos, caso precise alteramos apenas em um lugar e todos os outros lugares que possuem vínculo serão atingidos automaticamente)
    // aqui apenas os atributos e métodos essenciais/em comum entre as classes Filme e Serie, o resto, elas aplicarão depois/em seus próprios arquivos
    // aqui a nossa Série "é um título" e nosso filme também é um "título" pois eles serão como "filho" da nossa classe titulo, herdando suas caracteristicas e ações (metodos) mas também tendo suas próprias características
    /*
    * método construtor
    * método chamado AUTOMATICAMENTE após a criação/instanciação de um objeto a partir desta classe 
    * todo método chamado automaticamente em php começa com a sigla "__" antes de seu nome
    * não se pode definir um retorno no método construtor (logo, ele será omitido e não colocaremos)
    * um método construtor não retorna nada (não pode ter um return dentro dele), logo, ele possui um comportamento de subrotina, apenas EXECUTA o que está dentro de seu escopo no momento de construção (pois seu retorno é meio que explicíto, pois basicamente o "retorno" é o objeto criado, atribuindo valores para seus atributos/propriedades a partir dos parâmetros que ele recebeu, que foram passados no momento de criação do objeto no arquivo que criou este objeto), qualquer inicialização de propriedade/atributo é alocada no método construtor
    * para não ficar repetitivo como estava logo acima, onde, definimos os atributos, depois, pediamos parâmetros e ai sim passavamos os valores dos parâmetros para os atributos/propriedades, seria mais interessante facilitar este processo, onde o php nos permite indicar que, os "parâmetros" do método construtor serão promovidos a propriedaedes/atributos no momento em que o método construtor for chamado a primeira vez, assim evitando repetição de código, e o jeito de se fazer isso é muito simples! apenas colocar o modificador de acesso no parâmetro que irá virar nosso atributo, como abaixo: "private string $nome", pronto, ao ser inicializado, ele já será considerado uma atributo diretamente, logo não é necessário o código que tinhamos antes de: "$this-nome = $nome; $this->anoLancamento = $anoLancamento..." para setar os valores de cada atributo pois agora que nossos parâmetros viraram nossos atributos, isso já será feito automaticamente - isso só acontece no construtor - todos os parâmetros que virarão atributos/propriedades precisam estar com a tipagem definida (se é string, int, float...) para que as IDE não reclamem e evite problemas ao decorrer do sistema
    * na prática, essas propriedades são apenas de leitura (mas por que?), pois, após informadas na sua construção, elas não podem ser alteradas (sem contar com $notas, pois sempre posso inserir uma nota a mais, logo, estou modificando ela), porém o restante é apenas de leitura, pois após serem definidas na instância do objeto, elas apenas podem ser "lidas/visualizadas" através do método "get" (que temos até então) - chamamos esse conceito de "readonly", que também é uma palavra reservada no php, que serve para informar que certas propriedades só vão ter acesso de leitura (após serem escritas/definidas uma vez, não podem ser escritas/definidas/alteradas em nenhum outro momento), logo, como é um atributo privado, ele terá de ser modificado dentro da própria classe, porém ao tentar executar em um metódo privado esta linha: $this->nome = 'teste'; me retornará um erro no terminal devido a palavra reservada "readonly" atribuida ao meu atributo/propriedade $nome, e todos os atributos/propriedades com essa palavra reservada atribuida, podem ter seus valores definidos apenas uma vez (no caso, no seu momento de construção/instância do objeto a partir desta classe que estamos)
    * tornando os atributos públicos, pois como explicado acima, a palavra reservada readonly permite que o atributo seja escrito APENAS UMA VEZ, logo é impossível reescrever o contéudo delas mesmo de dentro da nossa classe (coisa que era permitida apenas com atributos privados sem essa palavra) logo, já que é IMPOSSIVEL os valores dos atributos/propriedades serem alterados após serem definidos a primeira vez, por que nãoe deixa-los publicos para facilitar o acesso deles no código normal? exatamente o que fizemos aqui, tornando-os publicos, podemos acessa-los de qualquer arquivo, logo, não tem mais a necessidade dos getters (métodos de acesso utilizados para acessar o valor de atributos privados, como não temos mais atributos privados, não precisamos mais deles, logo, serão removidos deste código aqui) 
    * inicialização dessas propriedades devem ser feitas dentro da classe em que foram criadas (não posso simplesmente criar, por exemplo o atributo nome fora de um construtor com a palavra readonly e atribuir o valor a ele no escopo global(ou seja, em outro arquivo), por mais que o valor esteja sendo definido pela primeira vez, no escopo global é a forma incorreta, deve ser feito na classe de origem)
    * devido ao fato de que o nosso atributo "$genero" tem uma possibilidade finita de valores, nos podemos encapsular/padronizar isso melhor, pois, por que deixar para o usuário decidir se, usando como base uma regra de negócios comum, não existem tantos genêros assim? (e orra, qual a chance de surgir um novo? mesmo surgindo, so acrescentarmos aqui), podemos facilitar o preenchimento do valor de genêro utilizando "enum" (ou seja, iremos enumerar os nossos genêros, onde, por exemplo o número 1 pode ser: "ação", o 2: "comédia" e assim por diante), onde a estruturação dele ficará no arquivo "Genero.php" 
    * agora meu atributo $genero é do tipo "Genero", assim passarei um valor do mesmo tipo para ele durante a instanciação do objeto no escopo global do sistema
    *essas anotações acima estavem em "filme" porém a regra das coisas veio para cá, logo, os comentários também
    */
    public function __construct(public readonly string $nome, public readonly int $anoLancamento, public readonly Genero $genero) {}

    // método abstrato (permitido apenas em classes abstratas, ou seja, classes que não podem ser instanciadas diretamente, apenas herdadas por outras classes) pois todas as classes filhas tem que ter este método (filme,série...) porém cada uma tem um jeito diferente de implementar este método, ou seja, o método, no MOMENTO atual não sabe sua forma, ele apenas terá uma no momento em que ele + seu corpo forem definidos em uma classe filha/subclasse que herdou da classe abstrata atual (Titulo), por isso é um método abstrato, ele terá diferentes formas (terá comportamentos diferentes) dependendo de qual classe filha for utiliza-lo
    // este método ainda é abstrato, ele (neste momento) ainda não tem uma implementação, quem for especializar a classe titulo (serie, filme, até mesmo mini-serie) ai sim precisará definir uma implementação para este método
    // palavra reservada abstract pode vir depois de "Public" porém por convenção e boas práticas, é recomendado colocar antes
    // ao extender de titulo, por esse método ser abstrato, é OBRIGATÓRIA a implementação deste método na classe filha de Titulo
    abstract public function duracaoEmMinutos(): int;
}
