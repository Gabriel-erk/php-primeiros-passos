<?php

/**
 * concreta = contrário de abstrata (pois concreta é algo já definido, abstrato algo que ainda está "em ideia")
 * Titulo é uma classe abstrata pois é genérica, é apenas uma base para outras classes (classes que irão se especializar a partir dessa aqui, se tornando em séries, filmes, mini séries, documentários...mas nunca deixando de ser um "titulo", pois as subclasses herdarão de título)
 * classes abstratas podem ter métodos abstratos (métodos que serão implementados (ou seja, terá uma definição de comportamento) pelas classes filhas obrigatoriamente. obs: para não ter que implementar o método abstrato da classe pai obrigatoriamente, a classe que herdou da classe abstrata teria de ser abstrata também , e por exemplo, série extendeu de Titulo, porém serie também é abstrata, logo, ela não é obrigada a implementar um método definido como abstrato na classe pai, porém a classe que herdar de série e não for abstrata tera de o fazer(definir uma implementação para o método abstrato da classe pai de Serie))
 * não podem ser instanciadas (ou seja, não é possivel fazer objetos a partir da classe titulo, apenad das classes filhas que NÃO são abstratas), ele ainda é um tipo, posso receber PARÂMETROS do tipo Titulo, posso retornar valores do tipo Titulo, porém a instância do objeto/variavel em si, o valor real (como por exemplo tentar acessar diretamnente os valores dos atributos de um titulo) é impossível, apenas se feito atráves da instancia de um objeto de uma classe filha/classe concreta (algo que herdou de titulo), tanto que, se repararmos, no nosso arquivo de calculadora recebemos uma "instância de titulo", porém, sempre será passado uma série ou filme (deixando nos parametros daquela forma: Titulo $titulo permite que passemos tanto um filme, serie, documentario... tudo para o mesmo método e ainda filtrando com uma tipagem correta (Titulo), bloqueando entradas do tipo "string, int, float..." e recebendo apenas o que precisamos, pois, no fundo, toda série, filme e documentário são um título por debaixo dos panos, imagina ter que fazer um método para cada tipo? um para série, outro documentário, outro filme.... ia ser uma bagunça, não? assim conseguimos "matar vários coelhos com uma cajadada só", permitindo apenas coisas que são titulo/herdem de título (séries, filmes, documentarios..))
 * "certo, porém e se eu tivesse mais alguma coisa nesse meu contexto que herdasse de titulo e não fizesse sentido ter esse método de "duração em minutos"?", nesse caso podemos fazer uma implementação falsa (apenas dando um return 0 para corresponder a sintaxe que EXIGE um retorno do tipo inteiro) ou usar a linha de raciocinio mais sensata, que é: "nesse nosso contexto/regra de negócio o que iria existir/qual classe iriamos criar herdando de titulo que NÃO FARIA SENTIDO ter o método duracaoEmMinutos?" exatamente, até onde consigo pensar, não tem nada e se tiver, realmente faz sentido? (se sim, vem a aplicação de esta classe que não precisa do metodo duracaoEmMinutos ser abstrata ou simplemente ter uma falsa implementação) porém, até onde consigo pensar, simplemente não faz sentido nenhuma nao ter, pois toda miniserie, documentario, video, propaganda (coisas que fariam sentido nessa aplicação/nossa regra de negócio) possuem uma duração em minutos, eles precisam desse método (cada um com seu jeito de implementar como vai funcionar a partir daquela classe que herdou de titulo), então, sim, com basse na nossa regra de negócio, tudo que herdar de titulo realmente faz sentido possuir esse método (obs: inclusive no exemplo do proximo video que irei ver, onde é mostrado que, teremos uma classe relacionada com episodios, e sim, todo episodio possui uma duração em minutos, logo, faz sentido TODO episiodio (todo objeto instanciado a partir da classe que iremos criar cuidando das funcionalidades e atributos dos "episodios") possuir esse método de duracaoEmMinutos())
 */
abstract class Titulo
{
    // classe "Titulo" que vai possuir as características em comum tanto da classe "Filme" quanto da classe "Serie", pois, eles tem muita coisa em comum e sem esse método que usaremos aqui, teriamos que repetir muito código, o que, pensando em boas práticas e no futuro, não é uma ação recomendada (pois, caso fique duplicando código, caso nossa regra de negócio mude ou aquela (por exemplo) método de problema ou precise de reestrutruração? teria que mudar tudo manualmente, o que pode causar um caos e mais problemas, dessa forma que faremos, caso precise alteramos apenas em um lugar e todos os outros lugares que possuem vínculo serão atingidos automaticamente)
    // aqui apenas os atributos e métodos essenciais/em comum entre as classes Filme e Serie, o resto, elas aplicarão depois/em seus próprios arquivos
    // aqui a nossa Série "é um título" e nosso filme também é um "título" pois eles serão como "filho" da nossa classe titulo, herdando suas caracteristicas e ações (metodos) mas também tendo suas próprias características
    private array $notas;
    /*
    * método construtor
    * método chamado AUTOMATICAMENTE após a criação/instanciação de um objeto a partir desta classe 
    * todo método chamado automaticamente em php começa com a sigla "__" antes de seu nome
    * não se pode definir um retorno no método construtor (logo, ele será omitido e não colocaremos)
    * um método construtor não retorna nada (não pode ter um return dentro dele), logo, ele possui um comportamento de subrotina, apenas EXECUTA o que está dentro de seu escopo no momento de construção (pois seu retorno é meio que explicíto, pois basicamente o "retorno" é o objeto criado, atribuindo valores para seus atributos/propriedades a partir dos parâmetros que ele recebeu, que foram passados no momento de criação do objeto no arquivo que criou este objeto), qualquer inicialização de propriedade/atributo é alocada no método construtor
    * para não ficar repetitivo como estava logo acima, onde, definimos os atributos, depois, pediamos parâmetros e ai sim passavamos os valores dos parâmetros para os atributos/propriedades, seria mais interessante facilitar este processo, onde o php nos permite indicar que, os "parâmetros" do método construtor serão promovidos a propriedaedes/atributos no momento em que o método construtor for chamado a primeira vez, assim evitando repetição de código, e o jeito de se fazer isso é muito simples! apenas colocar o modificador de acesso no parâmetro que irá virar nosso atributo, como abaixo: "private string $nome", pronto, ao ser inicializado, ele já será considerado uma atributo diretamente, logo não é necessário o código que tinhamos antes de: "$this-nome = $nome; $this->anoLancamento = $anoLancamento..." para setar os valores de cada atributo pois agora que nossos parâmetros viraram nossos atributos, isso já será feito automaticamente - isso só acontece no construtor - todos os parâmetros que virarão atributos/propriedades precisam estar com a tipagem definida (se é string, int, float...) para que as IDE não reclamem e evite problemas ao decorrer do sistema
    * na prática, essas propriedades são apenas de leitura (mas por que?), pois, após informadas na sua construção, elas não podem ser alteradas (sem contar com $notas, pois sempre posso inserir uma nota a mais, logo, estou modificando ela), porém o restante é apenas de leitura, pois após serem definidas na instância do objeto, elas apenas podem ser "lidas/visualizadas" através do método "get" (que temos até então) - chamamos esse conceito de "readonly", que também é uma palavra reservada no php, que serve para informar que certas propriedades só vão ter acesso de leitura (após serem escritas/definidas uma vez, não podem ser escritas/definidas/alteradas em nenhum outro momento), logo, como é um atributo privado, ele terá de ser modificado dentro da própria classe, porém ao tentar executar em um metódo privado esta linha: $this->nome = 'teste'; me retornará um erro no terminal devido a palavra reservada "readonly" atribuida ao meu atributo/propriedade $nome, e todos os atributos/propriedades com essa palavra reservada atribuida, podem ter seus valores definidos apenas uma vez (no caso, no seu momento de construção/instância do objeto a partir desta classe que estamos)
    * tornando os atributos públicos, pois como explicado acima, a palavra reservada readonly permite que o atributo seja escrito APENAS UMA VEZ, logo é impossível reescrever o contéudo delas mesmo de dentro da nossa classe (coisa que era permitida apenas com atributos privados sem essa palavra) logo, já que é IMPOSSIVEL os valores dos atributos/propriedades serem alterados após serem definidos a primeira vez, por que nãoe deixa-los publicos para facilitar o acesso deles no código normal? exatamente o que fizemos aqui, tornando-os publicos, podemos acessa-los de qualquer arquivo, logo, não tem mais a necessidade dos getters (métodos de acesso utilizados para acessar o valor de atributos privados, como não temos mais atributos privados, não precisamos mais deles, logo, serão removidos deste código aqui) 
    * inicialização dessas propriedades devem ser feitas dentro da classe em que foram criadas (não posso simplesmente criar, por exemplo o atributo nome fora de um construtor com a palavra readonly e atribuir o valor a ele no escopo global(ou seja, em outro arquivo), por mais que o valor esteja sendo definido pela primeira vez, no escopo global é a forma incorreta, deve ser feito na classe de origem)
    * devido ao fato de que o nosso atributo "$genero" tem uma possibilidade finita de valores, nos podemos encapsular/padronizar isso melhor, pois, por que deixar para o usuário decidir se, usando como base uma regra de negócios comum, não existem tantos genêros assim? (e orra, qual a chance de surgir um novo? mesmo surgindo, so acrescentarmos aqui), podemos facilitar o preenchimento do valor de genêro utilizando "enum" (ou seja, iremos enumerar os nossos genêros, onde, por exemplo o número 1 pode ser: "ação", o 2: "comédia" e assim por diante), onde a estruturação dele ficará no arquivo "Genero.php" 
    * agora meu atributo $genero é do tipo "Genero", assim passarei um valor do mesmo tipo para ele durante a instanciação do objeto no escopo global do sistema
    *essas anotações acima estavem em "filme" porém a regra das coisas veio para cá, logo, os comentários também
    */
    public function __construct(public readonly string $nome, public readonly int $anoLancamento, public readonly Genero $genero)
    {
        $this->notas = [];
    }

    // subrotina, pois não retorna nada, apenas realiza uma ação
    // modificador de acesso public para dizer que nosso método pode ser acessado de fora do nosso Filme, ou seja fora da nossa classe Filme
    public function avalia(float $nota): void
    {
        // para executar/chamar os métodos funções (serão chamados a partir de um objeto que instanciou esta classe), eu preciso especificar que estou chamando o atributo publico "$notas" do objeto que CHAMOU essa função, caso no meu objeto "$filme20" eu chame $filme20->avalia(10), dentro do método eu preciso estar especificando que, estou chamando o atributo $notas exatamente responsavel pelo $filme 20, se não, me gerará um erro e não conseguirei prosseguir com a execuçaõ do programa
        // devido a isso, é utilizado o "$this" antes de chamar os atributos da classe, pois os métodos/funções não o reconhecem, o atributos definidos fora do método não enxergam os atributos da minha classe sem a palavra $this antes do atributo em si
        // $this = esse (use o atributo para esse objeto que chamou a função)
        // $this = palavra reservada que indica o objeto utilizado para executar a função
        $this->notas[] = $nota;
    }

    public function media(): float
    {
        $somaNotas = array_sum($this->notas);
        // count conta a quantidade de itens dentro do array
        $quantidadeNotas = count($this->notas);
        return $somaNotas / $quantidadeNotas;
    }

    // método abstrato (permitido apenas em classes abstratas, ou seja, classes que não podem ser instanciadas diretamente, apenas herdadas por outras classes) pois todas as classes filhas tem que ter este método (filme,série...) porém cada uma tem um jeito diferente de implementar este método, ou seja, o método, no MOMENTO atual não sabe sua forma, ele apenas terá uma no momento em que ele + seu corpo forem definidos em uma classe filha/subclasse que herdou da classe abstrata atual (Titulo), por isso é um método abstrato, ele terá diferentes formas (terá comportamentos diferentes) dependendo de qual classe filha for utiliza-lo
    // este método ainda é abstrato, ele (neste momento) ainda não tem uma implementação, quem for especializar a classe titulo (serie, filme, até mesmo mini-serie) ai sim precisará definir uma implementação para este método
    // palavra reservada abstract pode vir depois de "Public" porém por convenção e boas práticas, é recomendado colocar antes
    // ao extender de titulo, por esse método ser abstrato, é OBRIGATÓRIA a implementação deste método na classe filha de Titulo
    abstract public function duracaoEmMinutos(): int;
}
